####C/C++

https://blog.csdn.net/zhouge000/article/details/81034017
https://blog.csdn.net/ly0303521/article/details/44306839

1.C语言中static关键字

    在C中，static主要定义全局静态变量、定义局部静态变量、定义静态函数
        * 定义全局静态变量：在全局变量前面加上关键字static，该全局变量变成了全局静态变量。全局静态变量有以下点：
        a. 在全局区分配内存
        b. 如果没有初始化，其默认值为0
        c. 该变量在本文件内从定义开始到文件结束可见
        * 定义局部静态变量：在局部变量前面加上关键字static，其特点如下：
        a. 该变量在全局数据区分配内存
        b. 它始终驻留在全局数据区，直到程序运行结束
        c. 其作用域为局部作用域，当定义它当函数或语句块结束时，其作用域随之结束
        * 定义静态函数：在函数返回类型前加上static关键字，函数即被定义为静态函数，其特点如下：
        a. 静态函数只能在本源文件中使用
        b. 在文件作用域中声明的inline函数默认为static类型。
    总结：用static定义的全局和局部静态变量的区别是，全局的静态变量的作用域和可见域都是从文件的定义开始到整个文件结束
    而局部的静态变量可见域是从文件的定义开始到整个文件结束，作用域是从该语句块的定义开始到该语句块结束

2.C语言中处理字符串的函数

    * strcat(arrayname1, arrayname2);
    strcat 将arrayname2连接到arrayname1的后面， 并删除原来arrayname1后的结束标志‘\0’. 这意味着 arrayname1 必须足够长 要能够同时容纳arratname1和arrayname2 否则会造成内存越界   strcat返回的是arrayname1的地址
    
    * strcpy 字符串复制函数 strcpy()   strncpy()
    * strcmp(arrayname1, arrayname2) 字符串比较   strncmp()
    arrayname1 和 arrayname2 是需要比较的两个字符串
    字符本身没有大小之分， 比较的是 每个字符对应的ASCII码值进行比较， 返回值  相等返回O 否则非0  大于0或者小于0
    * strcasecmp() 忽略大小写比较字符串
    * strlen() 返回字符串的实际长度
    * strstr(s1, s2) 判断s2是否是s1的子串  是的话返回子串的首地址  否则返回null
    * strchr(const char *s, char c) 查找字符串c首次在s中出现的位置
    

3.C++中 指针和引用的区别

    （1） 引用在创建时初始化  指针则在任何时候初始化
    （2） 一旦一个引用被初始化指向一个对象 它就不能被改变为对另一对象对引用，指针可以
    （3） 不能用NULL引用  可以有空指针
    （4） 指针是个实体 而引用是一个别名
    （5） 引用必须被初始化 指针不必
    （6） 可以有const指针 但是没有const引用
    （7） 程序为指针变量分配内存区域，而引用不需要分配内存区域
    （8） 指针可以有多级 而引用只能是一级


4.C++中重载 重写 虚函数 纯虚函数
    
    （1） 重载：函数名相同  参数列表不同。 重载只是在类的内部存在。但是不能靠返回类型来判断
    （2） 重写，发生在类中 必须有继承    子类重新定义父类中相同名称和参数的虚函数。函数特征相同。但是具体实现不同，主要在继承关系中体现
    重写虚也注意：
    (1). 重写的函数必须virtual的 不能用static
    (2). 重写函数必须有相同的类型 名称和参数列表
    (3). 重写的访问修饰符可以不同 
    纯虚函数 virtual {method body} = 0  必须要有 

4-1.C++的精华

    封装 继承 多态
    多态：三个条件
        1要有继承
        2虚函数重写
        3父类指针（父类引用）指向子类对象
    
    函数重载：
        必须在同一类进行
        子类无法重载父类的函数，父类同名函数将被覆盖
        重载是在编译期间根据参数类型和个数决定函数调用
    
    函数重写：
        必须发生在父类和子类之间
        并且父类和子类中的函数必须有完全相同的类型
        
        使用virtual产生多态 若不用virtual就是重定义
    多态是在运行期间根据具体对象的类型决定函数的调用
    
4-2.多态的理解
    
    多态的实现效果：同一种调用语句表现出不同的形态
    多态的三个条件：1 2 3
    多态的理论基础：动态联编 pk 静态联编 根据实际的对象类型来判断重写函数的调用
    多态的重要意义：设计模式的基础 是框架的基石
    
    实现多态的理论基础：
        函数指针做函数参数 虚函数表 虚函数指针 vptr 迟绑定 动态联编    


5.看的相关书 哪本更深刻
6.技术中的难点
7.strcpy函数实现
```C++
char *strcpy(char *dst, const char *src)
{
    assert(dst != NULL && src != NULL);
    char *ret = dst;
    while((*dst++ == *src++) != '\0');
    return ret;
}

```
8.bool, int ,float, double变量与0值的比较

    bool型：if(!flag) 或者 if flag falg为bool型
    int型：if(value == 0)  if(value !=0)
    float型： if(abs(a -b) <= epsilon) epsilon为精度   同理可以与0比较
    pointer型L： if (p == NULL) if(P != NULL)

9.什么是死锁 如何避免死锁
    
    deadlocks 指两个或两个以上的进程在执行过程中，因争夺资源 而造成的相互等待现象
    
    产生死锁的4个必要条件：
        互斥条件   不可破坏
        请求与保持条件  可
        不剥夺条件       可
        循环等待条件      可
    
    预防措施：
    1采用资源静态分配策略，破坏部分分配条件
    2允许进程剥夺使用其它进程占🈶有的资源  从而破坏死锁的必要条件
    3采用资源有序分配法 破坏环路条件

10.进程间的通信方式：
    
    1 管道 
    2 信号量 
    3 消息队列 
    4 共享队列 
    5 socket套接字

11.线程间的同步通信
    
    1信号量 
    2消息队列 
    3事件event

12.内存四区

| 堆区   |  栈区   | 全局区 | 代码区  |
|------  | -----: | -----: |:-----: |
| heap   |stack   |  gloal | code   |
| malloc/new free/delete| 程序局部变量  临时变量 | 常量 全局变量 操作系统管理| 操作系统管理

13.间接赋值成立的三个条件

    条件1：定义一个变量（实参） 1个变量 形参  
    条件2：建立关联 把实参取地址传给形参      int
    条件3：*形参去间接修改实参的值
    ```c
    int iNum = 0; 
    int *p = NULL;
    
    p = &iNum;
    
    inum = 1;
    *p = 2;
    
    
    
    #include <stdio.h>
    
    int main () {
    
        int iNum =0;
        int *p = NULL;
        p = &iNum;
        iNum = 1;
        *p = 2;
        printf("%d",iNum);
        
        return 0;
    } 
    
    #2
    ```
    
    间接赋值是指针存在的最大意义：
        
        1定义2个变量
        2建立关联
        3*p在被调函数中修改实参的值


14.用递归实现： sum(n) = 1*1 + 2*2 + ... + n*n

```c
long sum(n)
{
    if (n==1)
    {
        return 1;
    }
    else
    {
        return n*n + sum(n-1);
    }
}


// 执行结果
int main () 
{

    printf("%d", sum(3));
    
    return 0;
}   
#14


```
    
15.写一个函数 将其中的\t都转换成4个空格

```c
char *convert(char *strDest, const char *strSrc, int length)
{
    char *cp = strDest;
    int i = 0;
    while(*strSrc && i< length)
    {
        if (*srcSrc == '\t')
        {
            for(int j=0; j<4; j++) *cp++;
        }
        else
        {
            *cp++ = *strSrc;
        }
        strSrc++;
        i++;
    }
    retrun strDest;
}


```

16.用程序打印一个三角形

17.全局变量和局部变量的区别
    
    作用域和生存期不同：
        首先可知，全局变量作用域整个程序从声明到结束，但作用域也有失效的情况，即局部定义（同变量名）
    在这个局部内以新定义的变量状态为主。局部只是借用名字，使全局变量作用
    
18.内存泄漏和内存溢出

    * 内存泄漏：是指程序中一动态分配的堆内存由于某种原因程序未释放或无法释放，造成xitong

https://blog.csdn.net/qq_29996285/article/details/84337354

https://blog.csdn.net/yawdd/article/details/80010148

## C++服务端面试总结
### 1.项目
    讲清楚自己的项目内容，负责的工作，使用的技术，以及碰到的问题如何解决等
    
### 2.C++基础
    * i++和++i的区别
        * i++是先用后加，直接执行i+1 然后返回i的引用
        * ++i是先加后用，先创建i的副本然后i+1，最后返回副本
     
    * new和malloc的区别
        * new分配内存按照数据类型分配，malloc分配内存按照大小分配
        * new不仅分配一段内存，而且会调用构造函数，但是malloc不会
        * new返回的是指向对象的指针，而malloc返回的是void * 因为malloc的返回值一半都需要进行类型转化；
        * new是一个操作符 可以重载  malloc是一个库函数
        * new分配的内存要用delete销毁， malloc要用free来销毁，delete销毁的时候调用析构函数，而free不会
        * malloc内部不够的时候，可用relloc扩容，new没有这种操作
        * new如果分配失败会抛出bad_malloc异常，而malloc失败会返回NULL 因此对于new要用try catch 而malloc是判断指针的返回值
        * new和new[]的区别， new[]是一次分配所有内存，多次调用构造函数，分别搭配使用delete和delete[]
    
    * C++的多态性是如何实现的？虚函数表是什么？
    
    * C++继承中，父类和子类的构造函数和析构函数的调用顺序
        * 建立对象时，会先调用父类的构造函数再调用子类的构造函数。
        * 销魂对象时，会先调用子类的析构函数再调用父类的析构函数
        
    * C++内存分哪几块 分别存储什么变量
    
    
    * 解释一下只能指针是什么？功能？
        * 将基本类型指针封装成类对象指针（这个类肯定的是模版，以适用不同基本类型的需求），并在析构函数编写delete语句删除 指针指向的内存空间
        * 为了更容易且更安全的管理动态内存，C++推出了智能指针（smart pointer）类型来管理动态对象。智能指针存储指向动态对象的指针，用于动态对象生存周期的控制，能够确保自动正确的销毁动态分配的对象，防止内存泄漏。智能指针的主要作用就是用栈智能
     
    * C++的stl中有哪几种容器？
        1.序列容器（7ge）
        vector 向量 可以动态改变对象长度，提供随机访问 在尾部添加和删除元素的时间是常数，在头部或者中间就是线性时间
        deque 双端队列
        list 双向列表
        forward_list 实现了单链表 不可反转
        queue  队列
        priority_queue 优先级队列
        stack  栈
        
        2. 关联容器
        4中有序关联容器：set multiset map multimap

### 3.数据结构和算法
    
    * 栈和队列的区别
    * 平衡二叉树如何构造
      平衡二叉树的性质：
        一，它的左子树和右子树的深度值之差小于1
        二，它的左子树和右子树都是平衡二叉树
    
    * 链表中删除一个结点操作
    * 个人对于数据的认识，可以结合实际谈谈
    * 堆排序
    
### 4.数据库

    * 索引是什么，作用及采用的数据结构
    * 数据库优化的方法
    
### 5.计算机网络
    
    * TCP/IP模型分层
    * IP协议工作在哪一层
    * HTTPS协议
    * 三次握手和四次挥手的具体过程描述
    * 在三次过程中，如果服务器一直收不到客户端的ack会发生什么
    * TCP和UDP的区别
    
### 6.操作系统的基础

    * 进程和线程的区别
    * 多线程多进程多优缺点
    * 统一进程中的线程之间共享哪些变量
    * 有了进程为什么还需要线程
    * 进程间通信方式的种类
    * 同步和互斥
    * 死锁是如何产生的 解决方式
    
### 7.linux指令
    
    * 使用过哪些linux指令
    * 使用linux指令对文本进行词频统计
    * 自身使用linux的体会
    
### 8.分布式系统和linux集群

    * 谈谈你个人对分布式系统的理解
    * 有分布式系统的开发经验吗？
    * 负载均衡技术
    * 存储中的数据内容容灾和实施方案


    

图像：
1. 直方图函数（代码）
2. 获取特征点的方法
3. sift特征检测（简单描述） Harris算法
