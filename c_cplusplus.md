####C/C++

https://blog.csdn.net/zhouge000/article/details/81034017
https://blog.csdn.net/ly0303521/article/details/44306839

1. C语言中static关键字
在C中，static主要定义全局静态变量、定义局部静态变量、定义静态函数
    * 定义全局静态变量：在全局变量前面加上关键字static，该全局变量变成了全局静态变量。全局静态变量有以下点：
    a. 在全局区分配内存
    b. 如果没有初始化，其默认值为0
    c. 该变量在本文件内从定义开始到文件结束可见
    * 定义局部静态变量：在局部变量前面加上关键字static，其特点如下：
    a. 该变量在全局数据区分配内存
    b. 它始终驻留在全局数据区，直到程序运行结束
    c. 其作用域为局部作用域，当定义它当函数或语句块结束时，其作用域随之结束
    * 定义静态函数：在函数返回类型前加上static关键字，函数即被定义为静态函数，其特点如下：
    a. 静态函数只能在本源文件中使用
    b. 在文件作用域中声明的inline函数默认为static类型。
总结：用static定义的全局和局部静态变量的区别是，全局的静态变量的作用域和可见域都是从文件的定义开始到整个文件结束
而局部的静态变量可见域是从文件的定义开始到整个文件结束，作用域是从该语句块的定义开始到该语句块结束

2. C语言中处理字符串的函数
    * strcat(arrayname1, arrayname2);
    strcat 将arrayname2连接到arrayname1的后面， 并删除原来arrayname1后的结束标志‘\0’. 这意味着 arrayname1 必须足够长 要能够同时容纳arratname1和arrayname2 否则会造成内存越界   strcat返回的是arrayname1的地址
    
    * strcpy 字符串复制函数 strcpy()   strncpy()
    * strcmp(arrayname1, arrayname2) 字符串比较   strncmp()
    arrayname1 和 arrayname2 是需要比较的两个字符串
    字符本身没有大小之分， 比较的是 每个字符对应的ASCII码值进行比较， 返回值  相等返回O 否则非0  大于0或者小于0
    * strlen() 返回字符串的实际长度
    

3. C++中 指针和引用的区别
 （1） 引用在创建时初始化  指针则在任何时候初始化
 （2） 一旦一个引用被初始化指向一个对象 它就不能被改变为对另一对象对引用，指针可以
 （3） 不能用NULL引用  可以有空指针
 （4） 指针是个实体 而引用是一个别名
 （5） 引用必须被初始化 指针不必
 （6） 可以有const指针 但是没有const引用
 （7） 程序为指针变量分配内存区域，而引用不需要分配内存区域
 （8） 指针可以有多级 而引用只能是一级

4. C++中重载 重写 虚函数 纯虚函数

 （1） 重载：函数名相同  参数列表不同。 重载只是在类的内部存在。但是不能靠返回类型来判断
 （2） 重写，发生在类中 必须有继承    子类重新定义父类中相同名称和参数的虚函数。函数特征相同。但是具体实现不同，主要在继承关系中体现
  重写虚也注意：
  (1). 重写的函数必须virtual的 不能用static
  (2). 重写函数必须有相同的类型 名称和参数列表
  (3). 重写的访问修饰符可以不同 
  纯虚函数 virtual {method body} = 0  必须要有 

5. 看的相关书 哪本更深刻
6. 技术中的难点
7. strcpy函数实现
```C++
char *strcpy(char *dst, const char *src)
{
    assert(dst != NULL && src != NULL);
    char *ret = dst;
    while((*dst++ == *src++) != '\0');
    return ret;
}

```
8. bool, int ,float, double变量与0值的比较
bool型：if(!flag) 或者 if flag falg为bool型
int型：if(value == 0)  if(value !=0)
float型： if(abs(a -b) <= epsilon) epsilon为精度   同理可以与0比较
pointer型L： if (p == NULL) if(P != NULL)

9. 什么是死锁 如何避免死锁
deadlocks 指两个或两个以上的进程在执行过程中，因争夺资源 而造成的相互等待现象

产生死锁的4个必要条件：
    互斥条件   不可破坏
    请求与保持条件  可
    不剥夺条件       可
    循环等待条件      可

预防措施：
1采用资源静态分配策略，破坏部分分配条件
2允许进程剥夺使用其它进程占🈶有的资源  从而破坏死锁的必要条件
3采用资源有序分配法 破坏环路条件

10. 进程间的通信方式：
1管道 2信号量 3消息队列 4共享队列 5socket套接字

11. 线程间的同步通信
1信号量 2消息队列 3事件event

12. 内存四区


    | 堆区   |  栈区   | 全局区 | 代码区  |
    |------  | -----: | -----: |:-----: |
    | heap   |stack   |  gloal | code   |
    | malloc/new free/delete| 程序局部变量  临时变量 | 常量 全局变量 操作系统管理| 操作系统管理



图像：
1. 直方图函数（代码）
2. 获取特征点的方法
3. sift特征检测（简单描述） Harris算法
